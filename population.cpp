// Class automatically generated by Dev-C++ New Class wizard
//#include "mtrand.h"
#include "population.h" // class's header file
#include "BRand.hpp"
#include <math.h>
#include <vector>
#include <iostream>
#include <cstdlib>

double population::s;

void population::initialize(double sel)
{
s=sel;
}

// class constructor
population::population(int N)
{
    alleleholders[0]=N;
    alleleholders[1]=0;
    alleleholders[2]=0;
    size=N;
}

void population::mutateup(int n)
{
     for (int i=0;i<n;i++)
     {
         if ((alleleholders[0]!=0)&&(BRand::Controller.nextOpened()>((0.5*alleleholders[1])/alleleholders[0])))
         {alleleholders[0]-=1;
         alleleholders[1]+=1;}
         else if (alleleholders[1]!=0)
         {alleleholders[1]-=1;
         alleleholders[2]+=1;}
     }         

}

void population::mutatedown(int n)
{
     for (int i=0;i<n;i++)
     {
         if ((alleleholders[2]!=0)&&(BRand::Controller.nextOpened()>((0.5*alleleholders[1])/alleleholders[2])))
         {alleleholders[2]-=1;
         alleleholders[1]+=1;}
         else if (alleleholders[1]!=0)
         {alleleholders[1]-=1;
         alleleholders[0]+=1;}
     }          

}

void population::clear()
{
    alleleholders[0]=size;
    alleleholders[1]=0;
    alleleholders[2]=0;
}

void population::fix()
{
    alleleholders[0]=0;
    alleleholders[1]=0;
    alleleholders[2]=size;
}

double population::prob()
{
    double q=(alleleholders[0]+alleleholders[1]*0.5)/size;
    return q-s*q*(1-q)*(0.5-q);
}

void population::populate_from(population &p, int N)
{
    populate_from(p.prob(),N);
}

void population::populate_from(double prob, int N)
{
    alleleholders[0]=0;
    alleleholders[1]=0;
    alleleholders[2]=0;    
    if (N!=0) size=N;
    if (prob<0.5) //drawing a binomial variate works faster when p<0.5
       {alleleholders[0]=binom(size,prob*prob);
       alleleholders[1]=binom(size-alleleholders[0],2*prob/(1+prob));
       alleleholders[2]=size-alleleholders[0]-alleleholders[1];
       }
    else  //drawing a binomial variate works faster when p<0.5
       {prob=1-prob;
       alleleholders[2]=binom(size,prob*prob);
       alleleholders[1]=binom(size-alleleholders[2],2*prob/(1+prob));
       alleleholders[0]=size-alleleholders[2]-alleleholders[1];
       }        
}

int population::allelenum()
{
return (alleleholders[1]+2*alleleholders[2]);
}

double  population::freq()
{
return (0.5*alleleholders[1]+alleleholders[2])/size;
}

int population::binom(int n, double p)
{int x=0;
double y=0,c=log(1-p);
if (c==0)
   {//std::cout<<"c is zero!\n";
   return 0;}
while (1) 
    {
    y+=ceil(log(BRand::Controller.nextOpened())/c);
    if (y>n) return x;    
    x++;    
    } 
}

 
population& population::operator= (const population &Source)
{
    // do the copy
    size = Source.size;
    alleleholders[0]=Source.alleleholders[0];
    alleleholders[1]=Source.alleleholders[1];
    alleleholders[2]=Source.alleleholders[2];    
    // return the existing object
    return *this;
}

int population::choose_allele()
{double d=BRand::Controller.nextClosed();
if (d<(double(alleleholders[0])/size))
   return 0;
else if (d>(1-double(alleleholders[2])/size))
   return 2;
else
   return 1;

}

population::~population()
{
	std::cout<<"destructor called\n";

}
